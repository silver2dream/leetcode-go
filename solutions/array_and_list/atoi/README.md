### 解題骨幹（Skeleton）

1. **線性掃描（Two-pointer / Index）**
   只用一個索引 `i` 自左而右走過字串，整條流程「一次掃描到底」，時間複雜度 `O(n)`。

2. **四段流程**

   ```text
   ┌── Skip blanks ──┐
   │                  │
   └─► Sign ─► Number ─► Clamp ─► 回傳
   ```

    * **Skip blanks**：丟掉所有前導空白 `' '`。
    * **Sign**：若看到 `'+'` / `'-'` 就記錄，否則預設正號。
    * **Number**：在連續的 `'0'…'9'` 上累積數值（*自然會忽略前導 0*）。
    * **Clamp**：每加一位前，先判斷是否即將溢出 32-bit 範圍；若會，就直接回傳邊界值 `[-2^31, 2^31-1]`。

3. **常數額外空間**
   只需要幾個整數變數（`val / sign / index`），空間複雜度 `O(1)`。

---

### 關鍵細節（Pitfalls & Tips）

| 關鍵              | 為什麼重要                                           | 常見踩坑                               |
| --------------- | ----------------------------------------------- | ---------------------------------- |
| **即時計算溢出**      | 不必用 64-bit 再額外裁切；在「*乘 10 加 digit*」之前就能判斷是否超過邊界  | 先乘後判或用 `int64` 再轉回 int，容易寫錯或額外耗時   |
| **符號僅一次**       | `"+-12"`、`"--5"` 等情形：只看**第一個出現**且只能接受一個         | 沒有先判定就進入數字迴圈，導致把 `'-'` 當成數字前的雜訊    |
| **沒有數字 ⇒ 回傳 0** | `"   +"`、`"-"`、`"  abc"` 都應是 0                  | 忘了檢查 `val` 在數字段結束後是否仍為 0           |
| **遇到非數字立即停止**   | `"1337code"` 只取 1337；`"0-1"` 只能取 0              | 繼續往後掃會讀到不合法字元，或錯把 `'-'` 視為新符號      |
| **前導 0 無須特判**   | `val = val*10 + digit` 自然會吃掉 0                  | 特意用 `strings.TrimLeft` 會多做一次掃描，不划算 |
| **常量定義**        | `intMax := 1<<31 - 1; intMin := -1 << 31` 可避免魔數 | 手打 2147483647 易出錯，也不易閱讀            |

---

### 一句話總結

> **單指標一次掃描**，先丟空白、判一次正負，讀連續數字並在「乘 10 前」做 **32-bit 溢出預檢**，其餘情況（多餘符號、無數字、字元中斷）都自然落在「回傳 0 或提早結束」——掌握這個骨幹，實作就乾淨又安全。

**是不是「最佳」？**
對這類「逐字解析（parsing）」又 **僅需輸出一次結果** 的題型，單指標線性掃描基本上就是 *time-optimal*：

* **時間複雜度 O(n)**——必讀全字串，任何演算法都不可能快過此下界。
* **空間複雜度 O(1)**——題目只要求最後的整數，無須額外容器。

如果你再用兩次掃描（先 `Trim` 空白、再解析），或用 `int64` 先存完整值再裁切，其實只是做了多餘工；對 `n ≤ 200` 的本題影響不大，但在面試官眼裡屬於「可以更簡潔」。

---

## 如何從題目嗅出「一次掃描」的訊號？

| 題目線索                                     | 對應直覺                      | 解題決策                   |
| ---------------------------------------- | ------------------------- | ---------------------- |
| **規則描述是按「字元出現順序」一步步走**<br>（先空白→符號→數字→停止） | 典型左到右串流解析（stream parsing） | 用一個指標 `i` 往右移動即可完全貼合流程 |
| **輸出只與前綴有關**<br>後面遇到首個非數字就停止             | 解析過程中不需回頭看                | 不需要雙指標／切片；一次向前掃描就夠     |
| **邊界檢查是「讀下一位前就能確定」**<br>（乘 10 前預判溢出）     | 可以 *on-the-fly* 做 clamp   | 無需先存完整值再裁切             |
| **`s.length ≤ 200` ＆ 32-bit clamp**      | 整體資料量極小，重掃或轉型浪費           | 單掃描 + 常數變數是最簡化做法       |
| **沒有「重複查詢」或「子字串統計」需求**                   | 不用建索引表、樹或 DP              | 一次解析完畢即可返回             |

### 思考流程範例

1. **先問自己**：「我能不能只讀每個字元一次就決定所有狀態？」
   這題答案是 **能**——因為每個字元一旦判定是空白／符號／數字／其他，就永遠不會改變之前的決策。
2. **有沒有必須回頭看的資訊？**
   無。符號最多一個、溢出可在當下比較，字串尾部對結果沒有影響。
3. **需要額外資料結構嗎？**
   不需要；只要 `sign`、`val`、`i` 三個整數。

---

## 給自己的小 Checklist

* **解析規則是線性的？**→ 考慮單掃描
* **輸出與前綴有關、遇界停止？**→ 進一步強化單掃描可行
* **邊界／溢出可在當下決定？**→ 不用第二次處理
* **題目保證長度或型別限制？**→ 額外優化價值小，保持簡潔

一旦這幾項都打勾，你就可以大膽地寫「單指標線性掃描」——在面試官眼裡，這通常就是最 *clean*、也最貼合題意的實作。
